# MS-SQL Server Support Implementation Plan

This document details what is required to add Microsoft SQL Server support to the `DelayedQueueJDBC` implementation, based on analysis of the old Scala implementation.

## Executive Summary

The new Kotlin implementation has some groundwork for MS-SQL (JdbcDriver enum, MSSQLFilters), but is missing:

1. **MS-SQL specific `SQLVendorAdapter`**: All the locking hints (`UPDLOCK`, `READPAST`), `TOP N` syntax, conditional INSERT
2. **MS-SQL migrations**: Table creation with `NVARCHAR`, `DATETIMEOFFSET`, `BIGINT IDENTITY`
3. **MS-SQL specific SQL syntax**: Different from HSQLDB (`TOP N` vs `LIMIT`, `WITH (hints)` vs nothing)

---

## 1. SQL SYNTAX DIFFERENCES: HSQLDB vs MS-SQL

### 1.1 Row Limiting

| Database | Syntax | Example |
|----------|--------|---------|
| HSQLDB | `LIMIT N` at end | `SELECT ... LIMIT 10` |
| MS-SQL | `TOP N` after SELECT | `SELECT TOP 10 ...` |

### 1.2 Locking Hints

| Database | Syntax | Purpose |
|----------|--------|---------|
| HSQLDB | None (limited lock support) | N/A |
| MS-SQL | `WITH (UPDLOCK)` | Lock rows for update |
| MS-SQL | `WITH (UPDLOCK, READPAST)` | Lock + skip already-locked rows |

**Why this matters**: Without `READPAST`, concurrent `tryPoll` calls can block on the same locked row instead of skipping to the next available message.

### 1.3 Conditional INSERT

| Database | Approach | Example |
|----------|----------|---------|
| HSQLDB | Try INSERT, catch exception | Direct `INSERT INTO ...` |
| MS-SQL | `IF NOT EXISTS ... INSERT` | See below |

**MS-SQL Conditional INSERT** (from old code):
```sql
IF NOT EXISTS (
  SELECT 1 FROM table WHERE pKey = ? AND pKind = ?
)
BEGIN
  INSERT INTO table (pKey, pKind, payload, ...) VALUES (?, ?, ?, ...)
END
```

### 1.4 Identity Columns

| Database | Syntax |
|----------|--------|
| HSQLDB | `BIGINT GENERATED BY DEFAULT AS IDENTITY` |
| MS-SQL | `BIGINT IDENTITY(1,1)` |

### 1.5 Data Types

| Column | HSQLDB | MS-SQL |
|--------|--------|--------|
| pKey | `VARCHAR(200)` | `NVARCHAR(200)` |
| pKind | `VARCHAR(100)` | `NVARCHAR(100)` |
| payload | `VARCHAR(16777216)` or `CLOB` | `NVARCHAR(MAX)` |
| scheduledAt | `TIMESTAMP WITH TIME ZONE` | `DATETIMEOFFSET` |
| lockUuid | `VARCHAR(36)` | `VARCHAR(36)` |

---

## 2. OLD CODE MS-SQL IMPLEMENTATION ANALYSIS

### 2.1 `MsSqlServerDriver` Class

**File**: `old-code/delayed-queue-jdbc/src/main/scala/.../SQLVendorAdapter.scala` lines 325-403

```scala
final private class MsSqlServerDriver(dbDelayedQueueTableName: String)
  extends SQLVendorAdapter(dbDelayedQueueTableName) {

  // 1. SELECT FOR UPDATE with UPDLOCK
  override def selectForUpdateOneRow(pKind: PKind, key: String): Query0[DBTableRowWithId] =
    sql"""
      SELECT TOP 1
        id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
      FROM $table
      WITH (UPDLOCK)
      WHERE pKey = $key AND pKind = $pKind
    """.query

  // 2. SELECT first available with UPDLOCK + READPAST
  override def selectFirstAvailableWithLockQuery(pKind: PKind, now: OffsetDateTime) =
    sql"""
      SELECT TOP 1
        id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
      FROM $table
      WITH (UPDLOCK, READPAST)
      WHERE pKind = $pKind AND scheduledAt <= $now
      ORDER BY scheduledAt
    """.query

  // 3. Conditional INSERT
  override protected def insertOneRowFragment(row: DBTableRow): Fragment =
    fr"""
    IF NOT EXISTS (
      SELECT 1 FROM $table WHERE pKey = ${row.pKey} AND pKind = ${row.pKind}
    )
    BEGIN
      INSERT INTO $table (pKey, pKind, payload, scheduledAt, scheduledAtInitially, createdAt)
      VALUES (${row.pKey}, ${row.pKind}, ${row.payload}, ...)
    END
    """

  // 4. Bulk acquire with UPDLOCK + READPAST in subquery
  override def acquireManyOptimistically(
    pKind: PKind, limit: Int, lockUuid: LockUuid, timeout: FiniteDuration, now: OffsetDateTime
  ): Update0 =
    sql"""
    UPDATE $table
    SET lockUuid = $lockUuid, scheduledAt = $expireAt
    WHERE id IN (
      SELECT TOP $limit id
      FROM $table
      WITH (UPDLOCK, READPAST)
      WHERE pKind = $pKind AND scheduledAt <= $now
      ORDER BY scheduledAt
    )
    """.update
}
```

### 2.2 MS-SQL Migrations

The old code has multiple migration files for MS-SQL. The final schema (after all migrations) is:

```sql
-- Table structure
CREATE TABLE ${tableName} (
    id BIGINT IDENTITY(1,1) NOT NULL,
    pKey NVARCHAR(200) NOT NULL,
    pKind NVARCHAR(100) NOT NULL,
    payload NVARCHAR(MAX) NOT NULL,
    scheduledAt DATETIMEOFFSET NOT NULL,
    scheduledAtInitially DATETIMEOFFSET NOT NULL,
    lockUuid VARCHAR(36) NULL,
    createdAt DATETIMEOFFSET NOT NULL,
    PRIMARY KEY (pKey, pKind)
);

-- Unique index on id (not primary key, just unique)
CREATE UNIQUE INDEX ${tableName}__IdUniqueIndex ON ${tableName}(id);

-- Index for efficient polling
CREATE INDEX ${tableName}__ScheduledAtIndex ON ${tableName}(scheduledAt);
CREATE INDEX ${tableName}__KindPlusScheduledAtIndex ON ${tableName}(pKind, scheduledAt);

-- Index for efficient lookup by createdAt
CREATE INDEX ${tableName}__CreatedAtIndex ON ${tableName}(createdAt);

-- Index for lock-based operations
CREATE INDEX ${tableName}__LockUuidPlusIdIndex ON ${tableName}(lockUuid, id);
```

**Key differences from HSQLDB**:
- Primary key is `(pKey, pKind)` composite, not `id`
- `id` has a separate UNIQUE index
- Uses `NVARCHAR` and `DATETIMEOFFSET`

---

## 3. WHAT'S ALREADY IN PLACE (NEW CODE)

### 3.1 JdbcDriver Enum ✅

**File**: `delayedqueue-jvm/src/main/kotlin/.../JdbcDriver.kt`

```kotlin
public enum class JdbcDriver(public val className: String) {
    HSQLDB("org.hsqldb.jdbc.JDBCDriver"),
    MsSqlServer("com.microsoft.sqlserver.jdbc.SQLServerDriver"),
    Sqlite("org.sqlite.JDBC");
}
```

### 3.2 MSSQLFilters ✅

**File**: `delayedqueue-jvm/src/main/kotlin/.../SqlExceptionFilters.kt`

The exception filters for MS-SQL are already implemented:
- `transientFailure` (deadlock 1205, failed to resume transaction)
- `duplicateKey` (error codes 2627, 2601)
- `invalidTable` (error code 208)
- `objectAlreadyExists` (error codes 2714, 2705, 1913, 15248, 15335)
- `failedToResumeTransaction` (message-based detection)

### 3.3 `filtersForDriver()` Mapping ✅

Already maps `JdbcDriver.MsSqlServer` to `MSSQLFilters`.

---

## 4. WHAT'S MISSING (MUST IMPLEMENT)

### 4.1 `MsSqlServerAdapter` Class

Need to create a new adapter class similar to `HSQLDBAdapter`:

**File to create**: `delayedqueue-jvm/src/main/kotlin/.../jdbc/MsSqlServerAdapter.kt` (or add to `SQLVendorAdapter.kt`)

```kotlin
private class MsSqlServerAdapter(driver: JdbcDriver, tableName: String) :
    SQLVendorAdapter(driver, tableName) {
    
    // 1. Conditional INSERT using IF NOT EXISTS
    override fun insertOneRow(connection: Connection, row: DBTableRow): Boolean
    
    // 2. SELECT FOR UPDATE with UPDLOCK
    override fun selectForUpdateOneRow(connection: Connection, kind: String, key: String): DBTableRowWithId?
    
    // 3. SELECT first available with UPDLOCK + READPAST
    override fun selectFirstAvailableWithLock(connection: Connection, kind: String, now: Instant): DBTableRowWithId?
    
    // 4. Bulk acquire with UPDLOCK + READPAST in subquery
    override fun acquireManyOptimistically(...): Int
    
    // 5. Override selectByKey to use TOP 1 instead of LIMIT 1
    override fun selectByKey(connection: Connection, kind: String, key: String): DBTableRowWithId?
    
    // 6. Override selectAllAvailableWithLock to use TOP N instead of LIMIT N
    override fun selectAllAvailableWithLock(...): List<DBTableRowWithId>
}
```

### 4.2 MS-SQL Migrations

**File to create**: `delayedqueue-jvm/src/main/kotlin/.../jdbc/MsSqlServerMigrations.kt`

```kotlin
internal object MsSqlServerMigrations {
    fun getMigrations(tableName: String): List<Migration> = listOf(
        Migration.createTableIfNotExists(
            tableName = tableName,
            sql = """
                CREATE TABLE $tableName (
                    id BIGINT IDENTITY(1,1) NOT NULL,
                    pKey NVARCHAR(200) NOT NULL,
                    pKind NVARCHAR(100) NOT NULL,
                    payload NVARCHAR(MAX) NOT NULL,
                    scheduledAt DATETIMEOFFSET NOT NULL,
                    scheduledAtInitially DATETIMEOFFSET NOT NULL,
                    lockUuid VARCHAR(36) NULL,
                    createdAt DATETIMEOFFSET NOT NULL
                );
                
                ALTER TABLE $tableName ADD PRIMARY KEY (pKey, pKind);
                
                CREATE UNIQUE INDEX ${tableName}__IdUniqueIndex ON $tableName(id);
                CREATE INDEX ${tableName}__ScheduledAtIndex ON $tableName(scheduledAt);
                CREATE INDEX ${tableName}__KindPlusScheduledAtIndex ON $tableName(pKind, scheduledAt);
                CREATE INDEX ${tableName}__CreatedAtIndex ON $tableName(createdAt);
                CREATE INDEX ${tableName}__LockUuidPlusIdIndex ON $tableName(lockUuid, id);
            """
        )
    )
}
```

### 4.3 Update `SQLVendorAdapter.create()`

```kotlin
companion object {
    fun create(driver: JdbcDriver, tableName: String): SQLVendorAdapter =
        when (driver) {
            JdbcDriver.HSQLDB -> HSQLDBAdapter(driver, tableName)
            JdbcDriver.MsSqlServer -> MsSqlServerAdapter(driver, tableName)
            JdbcDriver.Sqlite -> TODO("SQLite support not yet implemented")
        }
}
```

### 4.4 Update `runMigrations()` in `DelayedQueueJDBC`

```kotlin
val migrations = when (config.db.driver) {
    JdbcDriver.HSQLDB -> HSQLDBMigrations.getMigrations(config.tableName)
    JdbcDriver.MsSqlServer -> MsSqlServerMigrations.getMigrations(config.tableName)
    JdbcDriver.Sqlite -> throw UnsupportedOperationException("SQLite not supported")
}
```

### 4.5 Add Abstract Method `selectForUpdateOneRow`

This method is **critical** and completely missing from the new code's `SQLVendorAdapter`:

```kotlin
// In SQLVendorAdapter.kt - add abstract method:
abstract fun selectForUpdateOneRow(
    connection: Connection,
    kind: String,
    key: String
): DBTableRowWithId?
```

**HSQLDB implementation**: Falls back to `selectByKey` (no real locking)
**MS-SQL implementation**: Uses `WITH (UPDLOCK)`

---

## 5. DETAILED IMPLEMENTATION

### 5.1 `MsSqlServerAdapter` Full Implementation

```kotlin
private class MsSqlServerAdapter(driver: JdbcDriver, tableName: String) :
    SQLVendorAdapter(driver, tableName) {

    /**
     * MS-SQL uses IF NOT EXISTS ... INSERT pattern for conditional insert.
     * This is more efficient than SELECT-then-INSERT because it's atomic.
     */
    override fun insertOneRow(connection: Connection, row: DBTableRow): Boolean {
        val sql = """
            IF NOT EXISTS (
                SELECT 1 FROM $tableName WHERE pKey = ? AND pKind = ?
            )
            BEGIN
                INSERT INTO $tableName
                (pKey, pKind, payload, scheduledAt, scheduledAtInitially, createdAt)
                VALUES (?, ?, ?, ?, ?, ?)
            END
        """
        return connection.prepareStatement(sql).use { stmt ->
            // Parameters for EXISTS check
            stmt.setString(1, row.pKey)
            stmt.setString(2, row.pKind)
            // Parameters for INSERT
            stmt.setString(3, row.pKey)
            stmt.setString(4, row.pKind)
            stmt.setString(5, row.payload)
            stmt.setTimestamp(6, java.sql.Timestamp.from(row.scheduledAt))
            stmt.setTimestamp(7, java.sql.Timestamp.from(row.scheduledAtInitially))
            stmt.setTimestamp(8, java.sql.Timestamp.from(row.createdAt))
            stmt.executeUpdate() > 0
        }
    }

    /**
     * SELECT FOR UPDATE using MS-SQL's UPDLOCK hint.
     * This prevents concurrent modifications to the same row.
     */
    override fun selectForUpdateOneRow(
        connection: Connection,
        kind: String,
        key: String
    ): DBTableRowWithId? {
        val sql = """
            SELECT TOP 1
                id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
            FROM $tableName
            WITH (UPDLOCK)
            WHERE pKey = ? AND pKind = ?
        """
        return connection.prepareStatement(sql).use { stmt ->
            stmt.setString(1, key)
            stmt.setString(2, kind)
            stmt.executeQuery().use { rs ->
                if (rs.next()) rs.toDBTableRowWithId() else null
            }
        }
    }

    /**
     * SELECT first available message with UPDLOCK + READPAST.
     * - UPDLOCK: Lock the selected row for update
     * - READPAST: Skip rows that are already locked by other transactions
     * 
     * This is critical for high-concurrency polling - without READPAST,
     * multiple pollers would block on the same row.
     */
    override fun selectFirstAvailableWithLock(
        connection: Connection,
        kind: String,
        now: Instant
    ): DBTableRowWithId? {
        val sql = """
            SELECT TOP 1
                id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
            FROM $tableName
            WITH (UPDLOCK, READPAST)
            WHERE pKind = ? AND scheduledAt <= ?
            ORDER BY scheduledAt
        """
        return connection.prepareStatement(sql).use { stmt ->
            stmt.setString(1, kind)
            stmt.setTimestamp(2, java.sql.Timestamp.from(now))
            stmt.executeQuery().use { rs ->
                if (rs.next()) rs.toDBTableRowWithId() else null
            }
        }
    }

    /**
     * Bulk acquire using UPDATE with subquery that has UPDLOCK + READPAST.
     * This atomically locks up to `limit` available messages.
     */
    override fun acquireManyOptimistically(
        connection: Connection,
        kind: String,
        limit: Int,
        lockUuid: String,
        timeout: Duration,
        now: Instant
    ): Int {
        require(limit > 0) { "Limit must be > 0" }
        val expireAt = now.plus(timeout)

        val sql = """
            UPDATE $tableName
            SET lockUuid = ?,
                scheduledAt = ?
            WHERE id IN (
                SELECT TOP $limit id
                FROM $tableName
                WITH (UPDLOCK, READPAST)
                WHERE pKind = ? AND scheduledAt <= ?
                ORDER BY scheduledAt
            )
        """
        return connection.prepareStatement(sql).use { stmt ->
            stmt.setString(1, lockUuid)
            stmt.setTimestamp(2, java.sql.Timestamp.from(expireAt))
            stmt.setString(3, kind)
            stmt.setTimestamp(4, java.sql.Timestamp.from(now))
            stmt.executeUpdate()
        }
    }

    /**
     * Override to use MS-SQL TOP syntax instead of LIMIT.
     */
    override fun selectByKey(connection: Connection, kind: String, key: String): DBTableRowWithId? {
        val sql = """
            SELECT TOP 1
                id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
            FROM $tableName
            WHERE pKey = ? AND pKind = ?
        """
        return connection.prepareStatement(sql).use { stmt ->
            stmt.setString(1, key)
            stmt.setString(2, kind)
            stmt.executeQuery().use { rs ->
                if (rs.next()) rs.toDBTableRowWithId() else null
            }
        }
    }

    /**
     * Override to use MS-SQL TOP syntax instead of LIMIT.
     */
    override fun selectAllAvailableWithLock(
        connection: Connection,
        lockUuid: String,
        count: Int,
        offsetId: Long?
    ): List<DBTableRowWithId> {
        val offsetClause = offsetId?.let { "AND id > ?" } ?: ""
        val sql = """
            SELECT TOP $count
                id, pKey, pKind, payload, scheduledAt, scheduledAtInitially, lockUuid, createdAt
            FROM $tableName
            WHERE lockUuid = ? $offsetClause
            ORDER BY id
        """
        return connection.prepareStatement(sql).use { stmt ->
            stmt.setString(1, lockUuid)
            offsetId?.let { stmt.setLong(2, it) }
            stmt.executeQuery().use { rs ->
                val results = mutableListOf<DBTableRowWithId>()
                while (rs.next()) {
                    results.add(rs.toDBTableRowWithId())
                }
                results
            }
        }
    }
}
```

---

## 6. TESTING CONSIDERATIONS

### 6.1 Unit Tests for SQL Generation

Test that the generated SQL is correct for MS-SQL:
- `TOP N` syntax
- `WITH (UPDLOCK)` hints
- `WITH (UPDLOCK, READPAST)` hints
- `IF NOT EXISTS ... INSERT` pattern

### 6.2 Integration Tests

For proper MS-SQL testing, you need:
1. **Docker container** with SQL Server (or Azure SQL Edge for ARM)
2. **TestContainers** integration (recommended)

```kotlin
@Testcontainers
class MsSqlServerIntegrationTest {
    companion object {
        @Container
        val sqlServer = MSSQLServerContainer("mcr.microsoft.com/mssql/server:2019-latest")
            .acceptLicense()
    }
    
    @Test
    fun `concurrent polls should not block`() {
        // Test that READPAST works correctly
    }
    
    @Test
    fun `conditional insert should be atomic`() {
        // Test that IF NOT EXISTS ... INSERT works
    }
}
```

### 6.3 Concurrency Tests

Critical tests specific to MS-SQL locking:
1. Multiple threads calling `tryPoll` - should not block each other (READPAST)
2. Multiple threads calling `offer` with same key - should not cause deadlocks
3. `tryPollMany` with concurrent single polls - should not over-acquire

---

## 7. WORK ITEMS CHECKLIST

### Phase 1: Core Infrastructure

- [ ] **1.1** Add abstract method `selectForUpdateOneRow` to `SQLVendorAdapter`
- [ ] **1.2** Update `HSQLDBAdapter` to implement `selectForUpdateOneRow` (delegate to `selectByKey`)
- [ ] **1.3** Create `MsSqlServerAdapter` class with all abstract method implementations
- [ ] **1.4** Update `SQLVendorAdapter.create()` to return `MsSqlServerAdapter` for MS-SQL

### Phase 2: Migrations

- [ ] **2.1** Create `MsSqlServerMigrations` object with table creation SQL
- [ ] **2.2** Update `DelayedQueueJDBC.runMigrations()` to use MS-SQL migrations
- [ ] **2.3** Verify migrations work with MS-SQL data types (`NVARCHAR`, `DATETIMEOFFSET`, `IDENTITY`)

### Phase 3: MS-SQL Specific SQL

- [ ] **3.1** Implement `insertOneRow` with `IF NOT EXISTS ... INSERT`
- [ ] **3.2** Implement `selectForUpdateOneRow` with `WITH (UPDLOCK)`
- [ ] **3.3** Implement `selectFirstAvailableWithLock` with `WITH (UPDLOCK, READPAST)`
- [ ] **3.4** Implement `acquireManyOptimistically` with subquery locking
- [ ] **3.5** Override `selectByKey` to use `TOP 1` instead of `LIMIT 1`
- [ ] **3.6** Override `selectAllAvailableWithLock` to use `TOP N`

### Phase 4: Fix Common Code (from behavioral differences plan)

These items must be done regardless of MS-SQL support but are prerequisites for correct behavior:

- [ ] **4.1** Fix `offer` to use optimistic INSERT-first approach
- [ ] **4.2** Fix `offer` to use `selectForUpdateOneRow` for updates
- [ ] **4.3** Add retry loop in `offer` for CAS failures
- [ ] **4.4** Fix `offerBatch` to use single key existence query
- [ ] **4.5** Fix `tryPoll` to retry on failed acquire

### Phase 5: Testing

- [ ] **5.1** Add unit tests for MS-SQL SQL generation
- [ ] **5.2** Set up TestContainers with MS-SQL Server
- [ ] **5.3** Add integration tests for MS-SQL specific features
- [ ] **5.4** Add concurrency tests for locking behavior (UPDLOCK, READPAST)
- [ ] **5.5** Add performance tests comparing HSQLDB vs MS-SQL

### Phase 6: Documentation

- [ ] **6.1** Update README with MS-SQL setup instructions
- [ ] **6.2** Document connection string format for MS-SQL
- [ ] **6.3** Document any MS-SQL specific configuration options

---

## 8. DEPENDENCIES

### Maven/Gradle Dependencies

```kotlin
// build.gradle.kts
dependencies {
    // MS-SQL JDBC driver (runtime only, not compile-time)
    runtimeOnly("com.microsoft.sqlserver:mssql-jdbc:12.4.2.jre11")
    
    // For testing with TestContainers
    testImplementation("org.testcontainers:mssqlserver:1.19.3")
}
```

### Note on Driver Loading

The MS-SQL JDBC driver is loaded at runtime via `Class.forName()` or automatically by the `DriverManager`. The code uses reflection for MS-SQL specific exception handling (`SQLServerException.getSQLServerError()`), so the driver doesn't need to be a compile-time dependency.

---

## 9. RISK ASSESSMENT

### High Risk Items

1. **Locking behavior differences**: MS-SQL's `UPDLOCK` + `READPAST` behaves differently than row-level locks in other databases. Need thorough testing.

2. **Timestamp precision**: MS-SQL's `DATETIMEOFFSET` has different precision than HSQLDB's `TIMESTAMP WITH TIME ZONE`. May affect timestamp truncation logic.

3. **Transaction isolation**: MS-SQL default isolation level is `READ COMMITTED`, which may behave differently than HSQLDB. May need explicit isolation level setting.

### Medium Risk Items

1. **Connection pooling**: HikariCP works with MS-SQL but may need driver-specific configuration.

2. **Batch operations**: `executeBatch()` behavior may differ. Need to verify batch insert error handling.

### Low Risk Items

1. **Exception handling**: `MSSQLFilters` is already implemented and tested (reflection-based).

2. **Driver class loading**: Standard JDBC, should work out of the box.
